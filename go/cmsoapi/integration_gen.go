// Package cmaoapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package cmaoapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AssetArchiveExtractionStatus.
const (
	Done       AssetArchiveExtractionStatus = "done"
	Failed     AssetArchiveExtractionStatus = "failed"
	InProgress AssetArchiveExtractionStatus = "in_progress"
	Pending    AssetArchiveExtractionStatus = "pending"
)

// Defines values for AssetPreviewType.
const (
	Geo        AssetPreviewType = "geo"
	Geo3dTiles AssetPreviewType = "geo_3d_Tiles"
	GeoMvt     AssetPreviewType = "geo_mvt"
	Image      AssetPreviewType = "image"
	ImageSvg   AssetPreviewType = "image_svg"
	Model3d    AssetPreviewType = "model_3d"
	Unknown    AssetPreviewType = "unknown"
)

// Defines values for AssetEmbedding.
const (
	All   AssetEmbedding = "all"
	False AssetEmbedding = "false"
	True  AssetEmbedding = "true"
)

// Defines values for CommentAuthorType.
const (
	Integrtaion CommentAuthorType = "integrtaion"
	User        CommentAuthorType = "user"
)

// Defines values for ValueType.
const (
	ValueTypeAsset     ValueType = "asset"
	ValueTypeBool      ValueType = "bool"
	ValueTypeDate      ValueType = "date"
	ValueTypeGroup     ValueType = "group"
	ValueTypeInteger   ValueType = "integer"
	ValueTypeMarkdown  ValueType = "markdown"
	ValueTypeReference ValueType = "reference"
	ValueTypeRichText  ValueType = "richText"
	ValueTypeSelect    ValueType = "select"
	ValueTypeTag       ValueType = "tag"
	ValueTypeText      ValueType = "text"
	ValueTypeTextArea  ValueType = "textArea"
	ValueTypeUrl       ValueType = "url"
)

// Defines values for RefParam.
const (
	RefParamLatest RefParam = "latest"
	RefParamPublic RefParam = "public"
)

// Defines values for SortDirParam.
const (
	SortDirParamAsc  SortDirParam = "asc"
	SortDirParamDesc SortDirParam = "desc"
)

// Defines values for SortParam.
const (
	SortParamCreatedAt SortParam = "createdAt"
	SortParamUpdatedAt SortParam = "updatedAt"
)

// Defines values for ItemGetParamsRef.
const (
	ItemGetParamsRefLatest ItemGetParamsRef = "latest"
	ItemGetParamsRefPublic ItemGetParamsRef = "public"
)

// Defines values for ItemFilterParamsSort.
const (
	ItemFilterParamsSortCreatedAt ItemFilterParamsSort = "createdAt"
	ItemFilterParamsSortUpdatedAt ItemFilterParamsSort = "updatedAt"
)

// Defines values for ItemFilterParamsDir.
const (
	ItemFilterParamsDirAsc  ItemFilterParamsDir = "asc"
	ItemFilterParamsDirDesc ItemFilterParamsDir = "desc"
)

// Defines values for ItemFilterParamsRef.
const (
	ItemFilterParamsRefLatest ItemFilterParamsRef = "latest"
	ItemFilterParamsRefPublic ItemFilterParamsRef = "public"
)

// Defines values for ItemFilterWithProjectParamsSort.
const (
	ItemFilterWithProjectParamsSortCreatedAt ItemFilterWithProjectParamsSort = "createdAt"
	ItemFilterWithProjectParamsSortUpdatedAt ItemFilterWithProjectParamsSort = "updatedAt"
)

// Defines values for ItemFilterWithProjectParamsDir.
const (
	ItemFilterWithProjectParamsDirAsc  ItemFilterWithProjectParamsDir = "asc"
	ItemFilterWithProjectParamsDirDesc ItemFilterWithProjectParamsDir = "desc"
)

// Defines values for ItemFilterWithProjectParamsRef.
const (
	ItemFilterWithProjectParamsRefLatest ItemFilterWithProjectParamsRef = "latest"
	ItemFilterWithProjectParamsRefPublic ItemFilterWithProjectParamsRef = "public"
)

// Defines values for AssetFilterParamsSort.
const (
	AssetFilterParamsSortCreatedAt AssetFilterParamsSort = "createdAt"
	AssetFilterParamsSortUpdatedAt AssetFilterParamsSort = "updatedAt"
)

// Defines values for AssetFilterParamsDir.
const (
	AssetFilterParamsDirAsc  AssetFilterParamsDir = "asc"
	AssetFilterParamsDirDesc AssetFilterParamsDir = "desc"
)

// Asset defines model for asset.
type Asset struct {
	ArchiveExtractionStatus *AssetArchiveExtractionStatus `json:"archiveExtractionStatus,omitempty"`
	ContentType             *string                       `json:"contentType,omitempty"`
	CreatedAt               time.Time                     `json:"createdAt"`
	File                    *File                         `json:"file,omitempty"`
	Id                      string                        `json:"id"`
	Name                    *string                       `json:"name,omitempty"`
	PreviewType             *AssetPreviewType             `json:"previewType,omitempty"`
	ProjectId               string                        `json:"projectId"`
	TotalSize               *float32                      `json:"totalSize,omitempty"`
	UpdatedAt               time.Time                     `json:"updatedAt"`
	Url                     string                        `json:"url"`
}

// AssetArchiveExtractionStatus defines model for Asset.ArchiveExtractionStatus.
type AssetArchiveExtractionStatus string

// AssetPreviewType defines model for Asset.PreviewType.
type AssetPreviewType string

// AssetEmbedding defines model for assetEmbedding.
type AssetEmbedding string

// Comment defines model for comment.
type Comment struct {
	AuthorId   *string            `json:"authorId,omitempty"`
	AuthorType *CommentAuthorType `json:"authorType,omitempty"`
	Content    *string            `json:"content,omitempty"`
	CreatedAt  *time.Time         `json:"createdAt,omitempty"`
	Id         *string            `json:"id,omitempty"`
}

// CommentAuthorType defines model for Comment.AuthorType.
type CommentAuthorType string

// Field defines model for field.
type Field struct {
	Group *string      `json:"group,omitempty"`
	Id    *string      `json:"id,omitempty"`
	Key   *string      `json:"key,omitempty"`
	Type  *ValueType   `json:"type,omitempty"`
	Value *interface{} `json:"value,omitempty"`
}

// File defines model for file.
type File struct {
	Children    *[]File  `json:"children,omitempty"`
	ContentType *string  `json:"contentType,omitempty"`
	Name        *string  `json:"name,omitempty"`
	Path        *string  `json:"path,omitempty"`
	Size        *float32 `json:"size,omitempty"`
}

// Model defines model for model.
type Model struct {
	CreatedAt        *time.Time `json:"createdAt,omitempty"`
	Description      *string    `json:"description,omitempty"`
	Id               *string    `json:"id,omitempty"`
	Key              *string    `json:"key,omitempty"`
	LastModified     *time.Time `json:"lastModified,omitempty"`
	MetadataSchemaId *string    `json:"metadataSchemaId,omitempty"`
	Name             *string    `json:"name,omitempty"`
	ProjectId        *string    `json:"projectId,omitempty"`
	Public           *bool      `json:"public,omitempty"`
	SchemaId         *string    `json:"schemaId,omitempty"`
	UpdatedAt        *time.Time `json:"updatedAt,omitempty"`
}

// ValueType defines model for valueType.
type ValueType string

// VersionedItem defines model for versionedItem.
type VersionedItem struct {
	CreatedAt       *time.Time            `json:"createdAt,omitempty"`
	Fields          *[]Field              `json:"fields,omitempty"`
	Id              *string               `json:"id,omitempty"`
	MetadataFields  *[]Field              `json:"metadataFields,omitempty"`
	ModelId         *string               `json:"modelId,omitempty"`
	Parents         *[]openapi_types.UUID `json:"parents,omitempty"`
	ReferencedItems *[]VersionedItem      `json:"referencedItems,omitempty"`
	Refs            *[]string             `json:"refs,omitempty"`
	UpdatedAt       *time.Time            `json:"updatedAt,omitempty"`
	Version         *openapi_types.UUID   `json:"version,omitempty"`
}

// AssetIdParam defines model for assetIdParam.
type AssetIdParam = string

// AssetParam defines model for assetParam.
type AssetParam = AssetEmbedding

// CommentIdParam defines model for commentIdParam.
type CommentIdParam = string

// ItemIdParam defines model for itemIdParam.
type ItemIdParam = string

// ModelIdOrKeyParam defines model for modelIdOrKeyParam.
type ModelIdOrKeyParam = string

// ModelIdParam defines model for modelIdParam.
type ModelIdParam = string

// PageParam defines model for pageParam.
type PageParam = int

// PerPageParam defines model for perPageParam.
type PerPageParam = int

// ProjectIdOrAliasParam defines model for projectIdOrAliasParam.
type ProjectIdOrAliasParam = string

// ProjectIdParam defines model for projectIdParam.
type ProjectIdParam = interface{}

// RefParam defines model for refParam.
type RefParam string

// SortDirParam defines model for sortDirParam.
type SortDirParam string

// SortParam defines model for sortParam.
type SortParam string

// AssetCommentCreateJSONBody defines parameters for AssetCommentCreate.
type AssetCommentCreateJSONBody struct {
	Content *string `json:"content,omitempty"`
}

// AssetCommentUpdateJSONBody defines parameters for AssetCommentUpdate.
type AssetCommentUpdateJSONBody struct {
	Content *string `json:"content,omitempty"`
}

// ItemGetParams defines parameters for ItemGet.
type ItemGetParams struct {
	// Ref Used to select a ref or ver
	Ref *ItemGetParamsRef `form:"ref,omitempty" json:"ref,omitempty"`

	// Asset Specifies whether asset data are embedded in the results
	Asset *AssetParam `form:"asset,omitempty" json:"asset,omitempty"`
}

// ItemGetParamsRef defines parameters for ItemGet.
type ItemGetParamsRef string

// ItemUpdateJSONBody defines parameters for ItemUpdate.
type ItemUpdateJSONBody struct {
	Asset          *AssetEmbedding `json:"asset,omitempty"`
	Fields         *[]Field        `json:"fields,omitempty"`
	MetadataFields *[]Field        `json:"metadataFields,omitempty"`
}

// ItemCommentCreateJSONBody defines parameters for ItemCommentCreate.
type ItemCommentCreateJSONBody struct {
	Content *string `json:"content,omitempty"`
}

// ItemCommentUpdateJSONBody defines parameters for ItemCommentUpdate.
type ItemCommentUpdateJSONBody struct {
	Content *string `json:"content,omitempty"`
}

// ItemFilterParams defines parameters for ItemFilter.
type ItemFilterParams struct {
	// Sort Used to define the order of the response list
	Sort *ItemFilterParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Dir Used to define the order direction of the response list, will be ignored if the order is not presented
	Dir *ItemFilterParamsDir `form:"dir,omitempty" json:"dir,omitempty"`

	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`

	// Ref Used to select a ref or ver
	Ref *ItemFilterParamsRef `form:"ref,omitempty" json:"ref,omitempty"`

	// Asset Specifies whether asset data are embedded in the results
	Asset *AssetParam `form:"asset,omitempty" json:"asset,omitempty"`
}

// ItemFilterParamsSort defines parameters for ItemFilter.
type ItemFilterParamsSort string

// ItemFilterParamsDir defines parameters for ItemFilter.
type ItemFilterParamsDir string

// ItemFilterParamsRef defines parameters for ItemFilter.
type ItemFilterParamsRef string

// ItemCreateJSONBody defines parameters for ItemCreate.
type ItemCreateJSONBody struct {
	Fields         *[]Field `json:"fields,omitempty"`
	MetadataFields *[]Field `json:"metadataFields,omitempty"`
}

// ItemFilterWithProjectParams defines parameters for ItemFilterWithProject.
type ItemFilterWithProjectParams struct {
	// Sort Used to define the order of the response list
	Sort *ItemFilterWithProjectParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Dir Used to define the order direction of the response list, will be ignored if the order is not presented
	Dir *ItemFilterWithProjectParamsDir `form:"dir,omitempty" json:"dir,omitempty"`

	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`

	// Ref Used to select a ref or ver
	Ref *ItemFilterWithProjectParamsRef `form:"ref,omitempty" json:"ref,omitempty"`

	// Asset Specifies whether asset data are embedded in the results
	Asset *AssetParam `form:"asset,omitempty" json:"asset,omitempty"`
}

// ItemFilterWithProjectParamsSort defines parameters for ItemFilterWithProject.
type ItemFilterWithProjectParamsSort string

// ItemFilterWithProjectParamsDir defines parameters for ItemFilterWithProject.
type ItemFilterWithProjectParamsDir string

// ItemFilterWithProjectParamsRef defines parameters for ItemFilterWithProject.
type ItemFilterWithProjectParamsRef string

// ItemCreateWithProjectJSONBody defines parameters for ItemCreateWithProject.
type ItemCreateWithProjectJSONBody struct {
	Fields         *[]Field `json:"fields,omitempty"`
	MetadataFields *[]Field `json:"metadataFields,omitempty"`
}

// AssetFilterParams defines parameters for AssetFilter.
type AssetFilterParams struct {
	// Sort Used to define the order of the response list
	Sort *AssetFilterParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Dir Used to define the order direction of the response list, will be ignored if the order is not presented
	Dir *AssetFilterParamsDir `form:"dir,omitempty" json:"dir,omitempty"`

	// Page Used to select the page
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Used to select the page
	PerPage *PerPageParam `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// AssetFilterParamsSort defines parameters for AssetFilter.
type AssetFilterParamsSort string

// AssetFilterParamsDir defines parameters for AssetFilter.
type AssetFilterParamsDir string

// AssetCreateJSONBody defines parameters for AssetCreate.
type AssetCreateJSONBody struct {
	SkipDecompression *bool   `json:"skipDecompression"`
	Url               *string `json:"url,omitempty"`
}

// AssetCreateMultipartBody defines parameters for AssetCreate.
type AssetCreateMultipartBody struct {
	File              *openapi_types.File `json:"file,omitempty"`
	SkipDecompression *bool               `json:"skipDecompression,omitempty"`
}

// AssetCommentCreateJSONRequestBody defines body for AssetCommentCreate for application/json ContentType.
type AssetCommentCreateJSONRequestBody AssetCommentCreateJSONBody

// AssetCommentUpdateJSONRequestBody defines body for AssetCommentUpdate for application/json ContentType.
type AssetCommentUpdateJSONRequestBody AssetCommentUpdateJSONBody

// ItemUpdateJSONRequestBody defines body for ItemUpdate for application/json ContentType.
type ItemUpdateJSONRequestBody ItemUpdateJSONBody

// ItemCommentCreateJSONRequestBody defines body for ItemCommentCreate for application/json ContentType.
type ItemCommentCreateJSONRequestBody ItemCommentCreateJSONBody

// ItemCommentUpdateJSONRequestBody defines body for ItemCommentUpdate for application/json ContentType.
type ItemCommentUpdateJSONRequestBody ItemCommentUpdateJSONBody

// ItemCreateJSONRequestBody defines body for ItemCreate for application/json ContentType.
type ItemCreateJSONRequestBody ItemCreateJSONBody

// ItemCreateWithProjectJSONRequestBody defines body for ItemCreateWithProject for application/json ContentType.
type ItemCreateWithProjectJSONRequestBody ItemCreateWithProjectJSONBody

// AssetCreateJSONRequestBody defines body for AssetCreate for application/json ContentType.
type AssetCreateJSONRequestBody AssetCreateJSONBody

// AssetCreateMultipartRequestBody defines body for AssetCreate for multipart/form-data ContentType.
type AssetCreateMultipartRequestBody AssetCreateMultipartBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AssetDelete request
	AssetDelete(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetGet request
	AssetGet(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetCommentList request
	AssetCommentList(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetCommentCreateWithBody request with any body
	AssetCommentCreateWithBody(ctx context.Context, assetId AssetIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetCommentCreate(ctx context.Context, assetId AssetIdParam, body AssetCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetCommentDelete request
	AssetCommentDelete(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetCommentUpdateWithBody request with any body
	AssetCommentUpdateWithBody(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetCommentUpdate(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, body AssetCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemDelete request
	ItemDelete(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemGet request
	ItemGet(ctx context.Context, itemId ItemIdParam, params *ItemGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemUpdateWithBody request with any body
	ItemUpdateWithBody(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemUpdate(ctx context.Context, itemId ItemIdParam, body ItemUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCommentList request
	ItemCommentList(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCommentCreateWithBody request with any body
	ItemCommentCreateWithBody(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemCommentCreate(ctx context.Context, itemId ItemIdParam, body ItemCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCommentDelete request
	ItemCommentDelete(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCommentUpdateWithBody request with any body
	ItemCommentUpdateWithBody(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemCommentUpdate(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, body ItemCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelGet request
	ModelGet(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemFilter request
	ItemFilter(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCreateWithBody request with any body
	ItemCreateWithBody(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemCreate(ctx context.Context, modelId ModelIdParam, body ItemCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelGetWithProject request
	ModelGetWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemFilterWithProject request
	ItemFilterWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemFilterWithProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemCreateWithProjectWithBody request with any body
	ItemCreateWithProjectWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemCreateWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ItemCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetFilter request
	AssetFilter(ctx context.Context, projectId ProjectIdParam, params *AssetFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetCreateWithBody request with any body
	AssetCreateWithBody(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetCreate(ctx context.Context, projectId ProjectIdParam, body AssetCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AssetDelete(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetDeleteRequest(c.Server, assetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetGet(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetGetRequest(c.Server, assetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentList(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentListRequest(c.Server, assetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentCreateWithBody(ctx context.Context, assetId AssetIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentCreateRequestWithBody(c.Server, assetId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentCreate(ctx context.Context, assetId AssetIdParam, body AssetCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentCreateRequest(c.Server, assetId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentDelete(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentDeleteRequest(c.Server, assetId, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentUpdateWithBody(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentUpdateRequestWithBody(c.Server, assetId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCommentUpdate(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, body AssetCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCommentUpdateRequest(c.Server, assetId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemDelete(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemDeleteRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemGet(ctx context.Context, itemId ItemIdParam, params *ItemGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemGetRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemUpdateWithBody(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemUpdateRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemUpdate(ctx context.Context, itemId ItemIdParam, body ItemUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemUpdateRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentList(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentListRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentCreateWithBody(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentCreateRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentCreate(ctx context.Context, itemId ItemIdParam, body ItemCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentCreateRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentDelete(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentDeleteRequest(c.Server, itemId, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentUpdateWithBody(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentUpdateRequestWithBody(c.Server, itemId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCommentUpdate(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, body ItemCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCommentUpdateRequest(c.Server, itemId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelGet(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelGetRequest(c.Server, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemFilter(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemFilterRequest(c.Server, modelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCreateWithBody(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCreateRequestWithBody(c.Server, modelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCreate(ctx context.Context, modelId ModelIdParam, body ItemCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCreateRequest(c.Server, modelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelGetWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelGetWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemFilterWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemFilterWithProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemFilterWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCreateWithProjectWithBody(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCreateWithProjectRequestWithBody(c.Server, projectIdOrAlias, modelIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemCreateWithProject(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ItemCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemCreateWithProjectRequest(c.Server, projectIdOrAlias, modelIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetFilter(ctx context.Context, projectId ProjectIdParam, params *AssetFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetFilterRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCreateWithBody(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCreateRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssetCreate(ctx context.Context, projectId ProjectIdParam, body AssetCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetCreateRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAssetDeleteRequest generates requests for AssetDelete
func NewAssetDeleteRequest(server string, assetId AssetIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetGetRequest generates requests for AssetGet
func NewAssetGetRequest(server string, assetId AssetIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetCommentListRequest generates requests for AssetCommentList
func NewAssetCommentListRequest(server string, assetId AssetIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetCommentCreateRequest calls the generic AssetCommentCreate builder with application/json body
func NewAssetCommentCreateRequest(server string, assetId AssetIdParam, body AssetCommentCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetCommentCreateRequestWithBody(server, assetId, "application/json", bodyReader)
}

// NewAssetCommentCreateRequestWithBody generates requests for AssetCommentCreate with any type of body
func NewAssetCommentCreateRequestWithBody(server string, assetId AssetIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssetCommentDeleteRequest generates requests for AssetCommentDelete
func NewAssetCommentDeleteRequest(server string, assetId AssetIdParam, commentId CommentIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetCommentUpdateRequest calls the generic AssetCommentUpdate builder with application/json body
func NewAssetCommentUpdateRequest(server string, assetId AssetIdParam, commentId CommentIdParam, body AssetCommentUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetCommentUpdateRequestWithBody(server, assetId, commentId, "application/json", bodyReader)
}

// NewAssetCommentUpdateRequestWithBody generates requests for AssetCommentUpdate with any type of body
func NewAssetCommentUpdateRequestWithBody(server string, assetId AssetIdParam, commentId CommentIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemDeleteRequest generates requests for ItemDelete
func NewItemDeleteRequest(server string, itemId ItemIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemGetRequest generates requests for ItemGet
func NewItemGetRequest(server string, itemId ItemIdParam, params *ItemGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Asset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemUpdateRequest calls the generic ItemUpdate builder with application/json body
func NewItemUpdateRequest(server string, itemId ItemIdParam, body ItemUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemUpdateRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewItemUpdateRequestWithBody generates requests for ItemUpdate with any type of body
func NewItemUpdateRequestWithBody(server string, itemId ItemIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemCommentListRequest generates requests for ItemCommentList
func NewItemCommentListRequest(server string, itemId ItemIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemCommentCreateRequest calls the generic ItemCommentCreate builder with application/json body
func NewItemCommentCreateRequest(server string, itemId ItemIdParam, body ItemCommentCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemCommentCreateRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewItemCommentCreateRequestWithBody generates requests for ItemCommentCreate with any type of body
func NewItemCommentCreateRequestWithBody(server string, itemId ItemIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemCommentDeleteRequest generates requests for ItemCommentDelete
func NewItemCommentDeleteRequest(server string, itemId ItemIdParam, commentId CommentIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemCommentUpdateRequest calls the generic ItemCommentUpdate builder with application/json body
func NewItemCommentUpdateRequest(server string, itemId ItemIdParam, commentId CommentIdParam, body ItemCommentUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemCommentUpdateRequestWithBody(server, itemId, commentId, "application/json", bodyReader)
}

// NewItemCommentUpdateRequestWithBody generates requests for ItemCommentUpdate with any type of body
func NewItemCommentUpdateRequestWithBody(server string, itemId ItemIdParam, commentId CommentIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModelGetRequest generates requests for ModelGet
func NewModelGetRequest(server string, modelId ModelIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemFilterRequest generates requests for ItemFilter
func NewItemFilterRequest(server string, modelId ModelIdParam, params *ItemFilterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dir", runtime.ParamLocationQuery, *params.Dir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Asset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemCreateRequest calls the generic ItemCreate builder with application/json body
func NewItemCreateRequest(server string, modelId ModelIdParam, body ItemCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemCreateRequestWithBody(server, modelId, "application/json", bodyReader)
}

// NewItemCreateRequestWithBody generates requests for ItemCreate with any type of body
func NewItemCreateRequestWithBody(server string, modelId ModelIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModelGetWithProjectRequest generates requests for ModelGetWithProject
func NewModelGetWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemFilterWithProjectRequest generates requests for ItemFilterWithProject
func NewItemFilterWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemFilterWithProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/items", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dir", runtime.ParamLocationQuery, *params.Dir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Asset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemCreateWithProjectRequest calls the generic ItemCreateWithProject builder with application/json body
func NewItemCreateWithProjectRequest(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ItemCreateWithProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemCreateWithProjectRequestWithBody(server, projectIdOrAlias, modelIdOrKey, "application/json", bodyReader)
}

// NewItemCreateWithProjectRequestWithBody generates requests for ItemCreateWithProject with any type of body
func NewItemCreateWithProjectRequestWithBody(server string, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectIdOrAlias", runtime.ParamLocationPath, projectIdOrAlias)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelIdOrKey", runtime.ParamLocationPath, modelIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s/items", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssetFilterRequest generates requests for AssetFilter
func NewAssetFilterRequest(server string, projectId ProjectIdParam, params *AssetFilterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/assets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dir", runtime.ParamLocationQuery, *params.Dir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetCreateRequest calls the generic AssetCreate builder with application/json body
func NewAssetCreateRequest(server string, projectId ProjectIdParam, body AssetCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetCreateRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewAssetCreateRequestWithBody generates requests for AssetCreate with any type of body
func NewAssetCreateRequestWithBody(server string, projectId ProjectIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/assets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AssetDeleteWithResponse request
	AssetDeleteWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetDeleteResponse, error)

	// AssetGetWithResponse request
	AssetGetWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetGetResponse, error)

	// AssetCommentListWithResponse request
	AssetCommentListWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetCommentListResponse, error)

	// AssetCommentCreateWithBodyWithResponse request with any body
	AssetCommentCreateWithBodyWithResponse(ctx context.Context, assetId AssetIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCommentCreateResponse, error)

	AssetCommentCreateWithResponse(ctx context.Context, assetId AssetIdParam, body AssetCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCommentCreateResponse, error)

	// AssetCommentDeleteWithResponse request
	AssetCommentDeleteWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*AssetCommentDeleteResponse, error)

	// AssetCommentUpdateWithBodyWithResponse request with any body
	AssetCommentUpdateWithBodyWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCommentUpdateResponse, error)

	AssetCommentUpdateWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, body AssetCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCommentUpdateResponse, error)

	// ItemDeleteWithResponse request
	ItemDeleteWithResponse(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*ItemDeleteResponse, error)

	// ItemGetWithResponse request
	ItemGetWithResponse(ctx context.Context, itemId ItemIdParam, params *ItemGetParams, reqEditors ...RequestEditorFn) (*ItemGetResponse, error)

	// ItemUpdateWithBodyWithResponse request with any body
	ItemUpdateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemUpdateResponse, error)

	ItemUpdateWithResponse(ctx context.Context, itemId ItemIdParam, body ItemUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemUpdateResponse, error)

	// ItemCommentListWithResponse request
	ItemCommentListWithResponse(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*ItemCommentListResponse, error)

	// ItemCommentCreateWithBodyWithResponse request with any body
	ItemCommentCreateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCommentCreateResponse, error)

	ItemCommentCreateWithResponse(ctx context.Context, itemId ItemIdParam, body ItemCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCommentCreateResponse, error)

	// ItemCommentDeleteWithResponse request
	ItemCommentDeleteWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*ItemCommentDeleteResponse, error)

	// ItemCommentUpdateWithBodyWithResponse request with any body
	ItemCommentUpdateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCommentUpdateResponse, error)

	ItemCommentUpdateWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, body ItemCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCommentUpdateResponse, error)

	// ModelGetWithResponse request
	ModelGetWithResponse(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*ModelGetResponse, error)

	// ItemFilterWithResponse request
	ItemFilterWithResponse(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, reqEditors ...RequestEditorFn) (*ItemFilterResponse, error)

	// ItemCreateWithBodyWithResponse request with any body
	ItemCreateWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCreateResponse, error)

	ItemCreateWithResponse(ctx context.Context, modelId ModelIdParam, body ItemCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCreateResponse, error)

	// ModelGetWithProjectWithResponse request
	ModelGetWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*ModelGetWithProjectResponse, error)

	// ItemFilterWithProjectWithResponse request
	ItemFilterWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemFilterWithProjectParams, reqEditors ...RequestEditorFn) (*ItemFilterWithProjectResponse, error)

	// ItemCreateWithProjectWithBodyWithResponse request with any body
	ItemCreateWithProjectWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCreateWithProjectResponse, error)

	ItemCreateWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ItemCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCreateWithProjectResponse, error)

	// AssetFilterWithResponse request
	AssetFilterWithResponse(ctx context.Context, projectId ProjectIdParam, params *AssetFilterParams, reqEditors ...RequestEditorFn) (*AssetFilterResponse, error)

	// AssetCreateWithBodyWithResponse request with any body
	AssetCreateWithBodyWithResponse(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCreateResponse, error)

	AssetCreateWithResponse(ctx context.Context, projectId ProjectIdParam, body AssetCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCreateResponse, error)
}

type AssetDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Asset
}

// Status returns HTTPResponse.Status
func (r AssetGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetCommentListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Comments *[]Comment `json:"comments,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetCommentListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetCommentListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetCommentCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Comment
}

// Status returns HTTPResponse.Status
func (r AssetCommentCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetCommentCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetCommentDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetCommentDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetCommentDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetCommentUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Comment
}

// Status returns HTTPResponse.Status
func (r AssetCommentUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetCommentUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ItemDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionedItem
}

// Status returns HTTPResponse.Status
func (r ItemGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionedItem
}

// Status returns HTTPResponse.Status
func (r ItemUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCommentListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Comments *[]Comment `json:"comments,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ItemCommentListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCommentListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCommentCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Comment
}

// Status returns HTTPResponse.Status
func (r ItemCommentCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCommentCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCommentDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ItemCommentDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCommentDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCommentUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Comment
}

// Status returns HTTPResponse.Status
func (r ItemCommentUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCommentUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r ModelGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items      *[]VersionedItem `json:"items,omitempty"`
		Page       *int             `json:"page,omitempty"`
		PerPage    *int             `json:"perPage,omitempty"`
		TotalCount *int             `json:"totalCount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ItemFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionedItem
}

// Status returns HTTPResponse.Status
func (r ItemCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelGetWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r ModelGetWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelGetWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemFilterWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items      *[]VersionedItem `json:"items,omitempty"`
		Page       *int             `json:"page,omitempty"`
		PerPage    *int             `json:"perPage,omitempty"`
		TotalCount *int             `json:"totalCount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ItemFilterWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemFilterWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemCreateWithProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionedItem
}

// Status returns HTTPResponse.Status
func (r ItemCreateWithProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemCreateWithProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items      *[]Asset `json:"items,omitempty"`
		Page       *int     `json:"page,omitempty"`
		PerPage    *int     `json:"perPage,omitempty"`
		TotalCount *int     `json:"totalCount,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Asset
}

// Status returns HTTPResponse.Status
func (r AssetCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AssetDeleteWithResponse request returning *AssetDeleteResponse
func (c *ClientWithResponses) AssetDeleteWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetDeleteResponse, error) {
	rsp, err := c.AssetDelete(ctx, assetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetDeleteResponse(rsp)
}

// AssetGetWithResponse request returning *AssetGetResponse
func (c *ClientWithResponses) AssetGetWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetGetResponse, error) {
	rsp, err := c.AssetGet(ctx, assetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetGetResponse(rsp)
}

// AssetCommentListWithResponse request returning *AssetCommentListResponse
func (c *ClientWithResponses) AssetCommentListWithResponse(ctx context.Context, assetId AssetIdParam, reqEditors ...RequestEditorFn) (*AssetCommentListResponse, error) {
	rsp, err := c.AssetCommentList(ctx, assetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentListResponse(rsp)
}

// AssetCommentCreateWithBodyWithResponse request with arbitrary body returning *AssetCommentCreateResponse
func (c *ClientWithResponses) AssetCommentCreateWithBodyWithResponse(ctx context.Context, assetId AssetIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCommentCreateResponse, error) {
	rsp, err := c.AssetCommentCreateWithBody(ctx, assetId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentCreateResponse(rsp)
}

func (c *ClientWithResponses) AssetCommentCreateWithResponse(ctx context.Context, assetId AssetIdParam, body AssetCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCommentCreateResponse, error) {
	rsp, err := c.AssetCommentCreate(ctx, assetId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentCreateResponse(rsp)
}

// AssetCommentDeleteWithResponse request returning *AssetCommentDeleteResponse
func (c *ClientWithResponses) AssetCommentDeleteWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*AssetCommentDeleteResponse, error) {
	rsp, err := c.AssetCommentDelete(ctx, assetId, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentDeleteResponse(rsp)
}

// AssetCommentUpdateWithBodyWithResponse request with arbitrary body returning *AssetCommentUpdateResponse
func (c *ClientWithResponses) AssetCommentUpdateWithBodyWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCommentUpdateResponse, error) {
	rsp, err := c.AssetCommentUpdateWithBody(ctx, assetId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentUpdateResponse(rsp)
}

func (c *ClientWithResponses) AssetCommentUpdateWithResponse(ctx context.Context, assetId AssetIdParam, commentId CommentIdParam, body AssetCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCommentUpdateResponse, error) {
	rsp, err := c.AssetCommentUpdate(ctx, assetId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCommentUpdateResponse(rsp)
}

// ItemDeleteWithResponse request returning *ItemDeleteResponse
func (c *ClientWithResponses) ItemDeleteWithResponse(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*ItemDeleteResponse, error) {
	rsp, err := c.ItemDelete(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemDeleteResponse(rsp)
}

// ItemGetWithResponse request returning *ItemGetResponse
func (c *ClientWithResponses) ItemGetWithResponse(ctx context.Context, itemId ItemIdParam, params *ItemGetParams, reqEditors ...RequestEditorFn) (*ItemGetResponse, error) {
	rsp, err := c.ItemGet(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemGetResponse(rsp)
}

// ItemUpdateWithBodyWithResponse request with arbitrary body returning *ItemUpdateResponse
func (c *ClientWithResponses) ItemUpdateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemUpdateResponse, error) {
	rsp, err := c.ItemUpdateWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemUpdateResponse(rsp)
}

func (c *ClientWithResponses) ItemUpdateWithResponse(ctx context.Context, itemId ItemIdParam, body ItemUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemUpdateResponse, error) {
	rsp, err := c.ItemUpdate(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemUpdateResponse(rsp)
}

// ItemCommentListWithResponse request returning *ItemCommentListResponse
func (c *ClientWithResponses) ItemCommentListWithResponse(ctx context.Context, itemId ItemIdParam, reqEditors ...RequestEditorFn) (*ItemCommentListResponse, error) {
	rsp, err := c.ItemCommentList(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentListResponse(rsp)
}

// ItemCommentCreateWithBodyWithResponse request with arbitrary body returning *ItemCommentCreateResponse
func (c *ClientWithResponses) ItemCommentCreateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCommentCreateResponse, error) {
	rsp, err := c.ItemCommentCreateWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentCreateResponse(rsp)
}

func (c *ClientWithResponses) ItemCommentCreateWithResponse(ctx context.Context, itemId ItemIdParam, body ItemCommentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCommentCreateResponse, error) {
	rsp, err := c.ItemCommentCreate(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentCreateResponse(rsp)
}

// ItemCommentDeleteWithResponse request returning *ItemCommentDeleteResponse
func (c *ClientWithResponses) ItemCommentDeleteWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, reqEditors ...RequestEditorFn) (*ItemCommentDeleteResponse, error) {
	rsp, err := c.ItemCommentDelete(ctx, itemId, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentDeleteResponse(rsp)
}

// ItemCommentUpdateWithBodyWithResponse request with arbitrary body returning *ItemCommentUpdateResponse
func (c *ClientWithResponses) ItemCommentUpdateWithBodyWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCommentUpdateResponse, error) {
	rsp, err := c.ItemCommentUpdateWithBody(ctx, itemId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentUpdateResponse(rsp)
}

func (c *ClientWithResponses) ItemCommentUpdateWithResponse(ctx context.Context, itemId ItemIdParam, commentId CommentIdParam, body ItemCommentUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCommentUpdateResponse, error) {
	rsp, err := c.ItemCommentUpdate(ctx, itemId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCommentUpdateResponse(rsp)
}

// ModelGetWithResponse request returning *ModelGetResponse
func (c *ClientWithResponses) ModelGetWithResponse(ctx context.Context, modelId ModelIdParam, reqEditors ...RequestEditorFn) (*ModelGetResponse, error) {
	rsp, err := c.ModelGet(ctx, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelGetResponse(rsp)
}

// ItemFilterWithResponse request returning *ItemFilterResponse
func (c *ClientWithResponses) ItemFilterWithResponse(ctx context.Context, modelId ModelIdParam, params *ItemFilterParams, reqEditors ...RequestEditorFn) (*ItemFilterResponse, error) {
	rsp, err := c.ItemFilter(ctx, modelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemFilterResponse(rsp)
}

// ItemCreateWithBodyWithResponse request with arbitrary body returning *ItemCreateResponse
func (c *ClientWithResponses) ItemCreateWithBodyWithResponse(ctx context.Context, modelId ModelIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCreateResponse, error) {
	rsp, err := c.ItemCreateWithBody(ctx, modelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCreateResponse(rsp)
}

func (c *ClientWithResponses) ItemCreateWithResponse(ctx context.Context, modelId ModelIdParam, body ItemCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCreateResponse, error) {
	rsp, err := c.ItemCreate(ctx, modelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCreateResponse(rsp)
}

// ModelGetWithProjectWithResponse request returning *ModelGetWithProjectResponse
func (c *ClientWithResponses) ModelGetWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, reqEditors ...RequestEditorFn) (*ModelGetWithProjectResponse, error) {
	rsp, err := c.ModelGetWithProject(ctx, projectIdOrAlias, modelIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelGetWithProjectResponse(rsp)
}

// ItemFilterWithProjectWithResponse request returning *ItemFilterWithProjectResponse
func (c *ClientWithResponses) ItemFilterWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, params *ItemFilterWithProjectParams, reqEditors ...RequestEditorFn) (*ItemFilterWithProjectResponse, error) {
	rsp, err := c.ItemFilterWithProject(ctx, projectIdOrAlias, modelIdOrKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemFilterWithProjectResponse(rsp)
}

// ItemCreateWithProjectWithBodyWithResponse request with arbitrary body returning *ItemCreateWithProjectResponse
func (c *ClientWithResponses) ItemCreateWithProjectWithBodyWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemCreateWithProjectResponse, error) {
	rsp, err := c.ItemCreateWithProjectWithBody(ctx, projectIdOrAlias, modelIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCreateWithProjectResponse(rsp)
}

func (c *ClientWithResponses) ItemCreateWithProjectWithResponse(ctx context.Context, projectIdOrAlias ProjectIdOrAliasParam, modelIdOrKey ModelIdOrKeyParam, body ItemCreateWithProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemCreateWithProjectResponse, error) {
	rsp, err := c.ItemCreateWithProject(ctx, projectIdOrAlias, modelIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemCreateWithProjectResponse(rsp)
}

// AssetFilterWithResponse request returning *AssetFilterResponse
func (c *ClientWithResponses) AssetFilterWithResponse(ctx context.Context, projectId ProjectIdParam, params *AssetFilterParams, reqEditors ...RequestEditorFn) (*AssetFilterResponse, error) {
	rsp, err := c.AssetFilter(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetFilterResponse(rsp)
}

// AssetCreateWithBodyWithResponse request with arbitrary body returning *AssetCreateResponse
func (c *ClientWithResponses) AssetCreateWithBodyWithResponse(ctx context.Context, projectId ProjectIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetCreateResponse, error) {
	rsp, err := c.AssetCreateWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCreateResponse(rsp)
}

func (c *ClientWithResponses) AssetCreateWithResponse(ctx context.Context, projectId ProjectIdParam, body AssetCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetCreateResponse, error) {
	rsp, err := c.AssetCreate(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetCreateResponse(rsp)
}

// ParseAssetDeleteResponse parses an HTTP response from a AssetDeleteWithResponse call
func ParseAssetDeleteResponse(rsp *http.Response) (*AssetDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetGetResponse parses an HTTP response from a AssetGetWithResponse call
func ParseAssetGetResponse(rsp *http.Response) (*AssetGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Asset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetCommentListResponse parses an HTTP response from a AssetCommentListWithResponse call
func ParseAssetCommentListResponse(rsp *http.Response) (*AssetCommentListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetCommentListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Comments *[]Comment `json:"comments,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetCommentCreateResponse parses an HTTP response from a AssetCommentCreateWithResponse call
func ParseAssetCommentCreateResponse(rsp *http.Response) (*AssetCommentCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetCommentCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetCommentDeleteResponse parses an HTTP response from a AssetCommentDeleteWithResponse call
func ParseAssetCommentDeleteResponse(rsp *http.Response) (*AssetCommentDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetCommentDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetCommentUpdateResponse parses an HTTP response from a AssetCommentUpdateWithResponse call
func ParseAssetCommentUpdateResponse(rsp *http.Response) (*AssetCommentUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetCommentUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemDeleteResponse parses an HTTP response from a ItemDeleteWithResponse call
func ParseItemDeleteResponse(rsp *http.Response) (*ItemDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemGetResponse parses an HTTP response from a ItemGetWithResponse call
func ParseItemGetResponse(rsp *http.Response) (*ItemGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemUpdateResponse parses an HTTP response from a ItemUpdateWithResponse call
func ParseItemUpdateResponse(rsp *http.Response) (*ItemUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCommentListResponse parses an HTTP response from a ItemCommentListWithResponse call
func ParseItemCommentListResponse(rsp *http.Response) (*ItemCommentListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCommentListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Comments *[]Comment `json:"comments,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCommentCreateResponse parses an HTTP response from a ItemCommentCreateWithResponse call
func ParseItemCommentCreateResponse(rsp *http.Response) (*ItemCommentCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCommentCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCommentDeleteResponse parses an HTTP response from a ItemCommentDeleteWithResponse call
func ParseItemCommentDeleteResponse(rsp *http.Response) (*ItemCommentDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCommentDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCommentUpdateResponse parses an HTTP response from a ItemCommentUpdateWithResponse call
func ParseItemCommentUpdateResponse(rsp *http.Response) (*ItemCommentUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCommentUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelGetResponse parses an HTTP response from a ModelGetWithResponse call
func ParseModelGetResponse(rsp *http.Response) (*ModelGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemFilterResponse parses an HTTP response from a ItemFilterWithResponse call
func ParseItemFilterResponse(rsp *http.Response) (*ItemFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items      *[]VersionedItem `json:"items,omitempty"`
			Page       *int             `json:"page,omitempty"`
			PerPage    *int             `json:"perPage,omitempty"`
			TotalCount *int             `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCreateResponse parses an HTTP response from a ItemCreateWithResponse call
func ParseItemCreateResponse(rsp *http.Response) (*ItemCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModelGetWithProjectResponse parses an HTTP response from a ModelGetWithProjectWithResponse call
func ParseModelGetWithProjectResponse(rsp *http.Response) (*ModelGetWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelGetWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemFilterWithProjectResponse parses an HTTP response from a ItemFilterWithProjectWithResponse call
func ParseItemFilterWithProjectResponse(rsp *http.Response) (*ItemFilterWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemFilterWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items      *[]VersionedItem `json:"items,omitempty"`
			Page       *int             `json:"page,omitempty"`
			PerPage    *int             `json:"perPage,omitempty"`
			TotalCount *int             `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseItemCreateWithProjectResponse parses an HTTP response from a ItemCreateWithProjectWithResponse call
func ParseItemCreateWithProjectResponse(rsp *http.Response) (*ItemCreateWithProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemCreateWithProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetFilterResponse parses an HTTP response from a AssetFilterWithResponse call
func ParseAssetFilterResponse(rsp *http.Response) (*AssetFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items      *[]Asset `json:"items,omitempty"`
			Page       *int     `json:"page,omitempty"`
			PerPage    *int     `json:"perPage,omitempty"`
			TotalCount *int     `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetCreateResponse parses an HTTP response from a AssetCreateWithResponse call
func ParseAssetCreateResponse(rsp *http.Response) (*AssetCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Asset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
